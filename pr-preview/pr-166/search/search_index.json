{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":""},{"location":"#hikari-orchestrator","title":"Hikari Orchestrator","text":"<p>A cute lil tool for orchestrating separate Hikari shard clusters.</p>"},{"location":"#usage","title":"Usage","text":""},{"location":"#subprocess-bot","title":"Subprocess Bot","text":"<p>Hikari Orchestrator can be used to shard a bot across multiple local threads on a single system. This uses subprocesses to allow the child bots to run in parallel.</p> <pre><code>def create_bot(bot: hikari.GatewayBotAware) -&gt; None:\n    tanjun.Client.from_gateway_bot(bot)\n\nhikari_orchestrator.run_subprocesses(os.environ[\"BOT_TOKEN\"], callback=create_bot)\n</code></pre> <p>Here we provide the bot's token and a callback which'll be called to setup each subprocesses' separate bot instance.</p> <p><code>intents</code> can also be passed to run_subprocesses to specify the intended gateway intents.</p> <p>Warning</p> <p>Since the callback is passed to child processes it needs to be picklable.</p> <pre><code>hikari_orchestrator run --entrypoint module.path:func --token \"Bot.Token\"\n</code></pre> <p>Subprocess bots can also be created using the <code>hikari_orchestrator run</code> (<code>hor run</code> for short) CLI command.</p> <p>This CLI command has two required arguments:</p> <ul> <li><code>--entrypoint</code>/<code>-ep</code> (<code>ORCHESTRATOR_ENTRYPOINT</code>): Path to the function which   will be called with each initialised   hikari.GatewayBotAware object.   This must be in the format of  <code>{module_path}:{function_name}</code>.</li> <li><code>token</code> (<code>DISCORD_TOKEN</code>): The bot's Discord token. It's recommended that   you provide this via its env variable rather than as a CLI argument.</li> </ul> <p>And several optional arguments:</p> <ul> <li><code>--intents</code> (<code>ORCHESTRATOR_INTENTS</code>): The gateway intents the bot should   declare. This defaults to <code>ALL_UNPRIVILEGED</code> and supports passing either the   raw integer flag or a <code>|</code>-separated list of intent names as defined by   hikari.Intents (e.g. <code>\"GUILD_MEMBERS|GUILD_MODERATION\"</code>).</li> <li><code>--shard-count</code> (<code>ORCHESTRATOR_SHARD_COUNT</code>): The amount of shards the bot's   going to havev. Defaults to Discord's recommended amount.</li> <li><code>--log-level</code> (<code>LOG_LEVEL</code>): Name of the logging level the bot should use.   Defaults to <code>\"INFO\"</code>.</li> <li><code>--process-count</code> (<code>ORCHESTRATOR_PROCESS_COUNT</code>): The amount of subprocesses   to spread the bot over. Default's to the system's CPU thread count.</li> <li><code>--entrypoint-dir</code> (<code>ORCHESTRATOR_ENTRYPOINT_DIR</code>): The folder to look for the   entrypoint's module in by adding it to PYTHONPATH. Defaults to the current   working directory.</li> </ul> <p>These arguments can also be provided using the environment variables which are shown in brackets (including as part of a <code>.env</code> file).</p>"},{"location":"#distributed-bot","title":"Distributed Bot","text":"<p>On a larger scale Hikari Orchestrator can also be used to manage shards across different machines.</p> <p>For this you'll want to first start up an Orchestrator server using the <code>hikari_orchestrator server</code> (<code>hor server</code> for short) CLI command or using run_server:</p> <pre><code>hikari_orchestrator server tcp://localhost:6969 --token \"Bot.Token\"\n</code></pre> <p>This CLI command has two required arguments:</p> <ul> <li>(<code>ORCHESTRATOR_ADDRESS</code>): The server's host address is the only positional   argument. TCP will be used if no scheme is included and more information on   the supported schemes can be found   here.</li> <li><code>--token</code> (<code>DISCORD_TOKEN</code>): The Discord bot token for the bot being   orchestrated. It's recommended that you provide this via its env variable   rather than as a CLI argument.</li> </ul> <p>And several optional arguments:</p> <ul> <li><code>--intents</code> (<code>ORCHESTRATOR_INTENTS</code>): The gateway intents the bot should   declare. This defaults to <code>ALL_UNPRIVILEGED</code> and supports passing either the   raw integer flag or a <code>|</code>-separated list of intent names as defined by   hikari.Intents (e.g. <code>\"GUILD_MEMBERS|GUILD_MODERATION\"</code>).</li> <li><code>--shard-count</code> (<code>ORCHESTRATOR_SHARD_COUNT</code>): The amount of shards the   bot's going to have. Defaults to Discord's recommended amount.</li> <li><code>--log-level</code> (<code>LOG_LEVEL</code>): Name of the logging level the server should use.   Defaults to <code>\"INFO\"</code>.</li> <li><code>--ca-cert</code> &amp; <code>--private-key</code> (<code>ORCHESTRATOR_CA_CERT</code> &amp; <code>ORCHESTRATOR_PRIVATE_KEY</code>):   Paths to the unencrypted PEM keys which act as the certificate authority and   private key for the server to use to SSL encrypt TCP connections.</li> </ul> <p>These arguments can also be provided using the environment variables which are shown in brackets (including as part of a <code>.env</code> file).</p> <pre><code>bot = hikari_orchestrator.Bot(\"localhost:6969\", os.environ[\"BOT_TOKEN\"], local_shard_count=1)\n\ntanjun.Client.from_gateway_bot(bot)\n\nbot.run()\n</code></pre> <p>Then you need to startup some child bot instances. For this you'll use Orchestrator's Bot implementation of GatewayBotAware which needs to be given the Orchestrator server's address and the bot's token but otherwise can be used just like the standard gateway bot. <code>local_shard_count</code> indicates how many shards the bot instance should try to startup.</p> <p>Note</p> <p>To use SSL encryption for TCP connections you'll need to pass the unencrypted certificate authority PEM as bytes to Bot.__init__ as <code>ca_cert=bytes</code>.</p>"},{"location":"changelog/","title":"Changelog","text":"<p>All notable changes to this project will be documented in this file.</p> <p>The format is based on Keep a Changelog, and this project adheres to Semantic Versioning.</p>"},{"location":"changelog/#unreleased","title":"Unreleased","text":""},{"location":"changelog/#removed","title":"Removed","text":"<ul> <li>Support for Python 3.9 and 3.10.</li> </ul>"},{"location":"changelog/#021-2024-10-07","title":"0.2.1 - 2024-10-07","text":""},{"location":"changelog/#changed","title":"Changed","text":"<ul> <li>Support Python 3.13.</li> </ul>"},{"location":"changelog/#020-2023-12-29","title":"0.2.0 - 2023-12-29","text":""},{"location":"changelog/#added","title":"Added","text":"<ul> <li><code>hor</code> commandline shorthand for <code>hikari_orchestrator</code>.</li> <li><code>hikari_orchestrator run</code> command for spawning a multiprocess bot from an entry function and basic config.</li> </ul>"},{"location":"changelog/#changed_1","title":"Changed","text":"<ul> <li>Renamed the <code>hikari_orchestrator</code> commandline command to <code>hikari_orchestrator server</code>.</li> </ul>"},{"location":"changelog/#012-2023-12-29","title":"0.1.2 - 2023-12-29","text":""},{"location":"changelog/#added_1","title":"Added","text":"<ul> <li>Support for Python 3.12.</li> </ul>"},{"location":"changelog/#011-2023-07-30","title":"0.1.1 - 2023-07-30","text":""},{"location":"changelog/#fixed","title":"Fixed","text":"<ul> <li>The CLI entry point now loads the dotenv file when being called as a project script.</li> <li><code>--private-key</code> now correctly pulls from the env variable <code>\"ORCHESTRATOR_PRIVATE_KEY\"</code>.</li> </ul>"},{"location":"changelog/#010-2023-07-29","title":"0.1.0 - 2023-07-29","text":""},{"location":"changelog/#added_2","title":"Added","text":"<ul> <li>Initial implementation.</li> </ul>"},{"location":"reference/","title":"Reference","text":""},{"location":"reference/#api-refernecce","title":"API Refernecce","text":"<p>System for managing hikari shards across processes/systems.</p>"},{"location":"reference/#hikari_orchestrator.Bot","title":"Bot","text":"<p>               Bases: <code>GatewayBotAware</code></p> <p>Bot implementation which is managed by an Orchestrator server.</p>"},{"location":"reference/#hikari_orchestrator.Bot.__init__","title":"__init__","text":"<pre><code>__init__(orchestrator_address, token, /, *, cache_settings=None, ca_cert=None, http_settings=None, intents=None, proxy_settings=None, rest_url=hikari.urls.REST_API_URL, global_shard_count=None, local_shard_count=1)\n</code></pre> <p>Initialise an orchestrator Bot.</p> <p>Parameters:</p> <ul> <li> <code>orchestrator_address</code>               (<code>str</code>)           \u2013            <p>Address the orchestrator server is hosted at.</p> </li> <li> <code>token</code>               (<code>str</code>)           \u2013            <p>Discord bot token to use.</p> </li> <li> <code>cache_settings</code>               (<code>CacheSettings | None</code>, default:                   <code>None</code> )           \u2013            <p>The cache settings to use.</p> </li> <li> <code>ca_cert</code>               (<code>bytes | None</code>, default:                   <code>None</code> )           \u2013            <p>Certificate authority certificate used by the orchestrator server for TLS SSL.</p> </li> <li> <code>http_settings</code>               (<code>HTTPSettings | None</code>, default:                   <code>None</code> )           \u2013            <p>Configuration to use for the REST client.</p> </li> <li> <code>proxy_settings</code>               (<code>ProxySettings | None</code>, default:                   <code>None</code> )           \u2013            <p>Custom proxy settings to use with network-layer logic in your application to get through an HTTP-proxy.</p> </li> <li> <code>rest_url</code>               (<code>str</code>, default:                   <code>REST_API_URL</code> )           \u2013            <p>Base URl to use for requests made by the REST client.</p> </li> <li> <code>local_shard_count</code>               (<code>int</code>, default:                   <code>1</code> )           \u2013            <p>Amount of shards this bot should spawn locally.</p> </li> </ul>"},{"location":"reference/#hikari_orchestrator.Client","title":"Client","text":"<p>Client for interacting with an orchestrator server instance.</p>"},{"location":"reference/#hikari_orchestrator.Client.remote_shards","title":"remote_shards  <code>property</code>","text":"<pre><code>remote_shards\n</code></pre> <p>Mapping of shard IDs to shard objects.</p> <p>These shard objects can be used to remotely monitor and control shards and will only be populated while the client is active.</p>"},{"location":"reference/#hikari_orchestrator.Client.__init__","title":"__init__","text":"<pre><code>__init__(token, orchestrator_address, /, *, ca_cert=None)\n</code></pre> <p>Initialise an orchestrator client.</p> <p>Parameters:</p> <ul> <li> <code>token</code>               (<code>str</code>)           \u2013            <p>Discord token for the bot that's being orchestrated.</p> </li> <li> <code>orchestrator_address</code>               (<code>str</code>)           \u2013            <p>Address the orchestrator server is being hosted at.</p> </li> <li> <code>ca_cert</code>               (<code>bytes | None</code>, default:                   <code>None</code> )           \u2013            <p>The certificate authority being used by the server for TLS SSL.</p> </li> </ul>"},{"location":"reference/#hikari_orchestrator.Client.fetch_all_states","title":"fetch_all_states  <code>async</code>","text":"<pre><code>fetch_all_states()\n</code></pre> <p>Fetch the states of all of the bot's shards.</p>"},{"location":"reference/#hikari_orchestrator.Client.fetch_config","title":"fetch_config  <code>async</code>","text":"<pre><code>fetch_config()\n</code></pre> <p>Fetch the bot config.</p>"},{"location":"reference/#hikari_orchestrator.Client.recommended_shard","title":"recommended_shard  <code>async</code>","text":"<pre><code>recommended_shard(make_shard)\n</code></pre> <p>Acquire the next shard recommended by the server.</p>"},{"location":"reference/#hikari_orchestrator.Client.request_guild_members","title":"request_guild_members  <code>async</code>","text":"<pre><code>request_guild_members(guild, *, include_presences=hikari.UNDEFINED, query='', limit=0, users=hikari.UNDEFINED, nonce=hikari.UNDEFINED)\n</code></pre> <p>Request for a guild chunk.</p> <p>The received guild chunks will be sent to the shard the guild is in, not necessarily the current shard.</p> <p>Note</p> <p>To request the full list of members, leave <code>query</code> as <code>\"\"</code> (empty string) and <code>limit</code> as <code>0</code>.</p> <p>Parameters:</p> <ul> <li> <code>guild</code>               (<code>SnowflakeishOr[PartialGuild]</code>)           \u2013            <p>The guild to request chunk for.</p> </li> <li> <code>include_presences</code>               (<code>UndefinedOr[bool]</code>, default:                   <code>UNDEFINED</code> )           \u2013            <p>If provided, whether to request presences.</p> </li> <li> <code>query</code>               (<code>str</code>, default:                   <code>''</code> )           \u2013            <p>If not <code>\"\"</code>, request the members which username starts with the string.</p> </li> <li> <code>limit</code>               (<code>int</code>, default:                   <code>0</code> )           \u2013            <p>Maximum number of members to send matching the query.</p> </li> <li> <code>users</code>               (<code>UndefinedOr[SnowflakeishSequence[User]]</code>, default:                   <code>UNDEFINED</code> )           \u2013            <p>If provided, the users to request for.</p> </li> <li> <code>nonce</code>               (<code>UndefinedOr[str]</code>, default:                   <code>UNDEFINED</code> )           \u2013            <p>If provided, the nonce to be sent with guild chunks.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>ValueError</code>             \u2013            <p>When trying to specify <code>users</code> with <code>query</code>/<code>limit</code>, if <code>limit</code> is not between 0 and 100, both inclusive or if <code>users</code> length is over 100.</p> </li> <li> <code>MissingIntentError</code>             \u2013            <p>When trying to request presences without the <code>GUILD_MEMBERS</code> or when trying to request the full list of members without <code>GUILD_PRESENCES</code>.</p> </li> </ul>"},{"location":"reference/#hikari_orchestrator.Client.start","title":"start  <code>async</code>","text":"<pre><code>start()\n</code></pre> <p>Start the client by connecting to the orchestrator.</p>"},{"location":"reference/#hikari_orchestrator.Client.stop","title":"stop  <code>async</code>","text":"<pre><code>stop()\n</code></pre> <p>Stop the orchestrator client.</p>"},{"location":"reference/#hikari_orchestrator.Client.update_presence","title":"update_presence  <code>async</code>","text":"<pre><code>update_presence(*, idle_since=hikari.UNDEFINED, afk=hikari.UNDEFINED, activity=hikari.UNDEFINED, status=hikari.UNDEFINED)\n</code></pre> <p>Update the presence of every shard in this bot.</p> <p>This state will be remembered between restarts.</p> <p>Parameters:</p> <ul> <li> <code>idle_since</code>               (<code>UndefinedNoneOr[datetime]</code>, default:                   <code>UNDEFINED</code> )           \u2013            <p>The datetime that the user started being idle. If undefined, this will not be changed.</p> </li> <li> <code>afk</code>               (<code>UndefinedOr[bool]</code>, default:                   <code>UNDEFINED</code> )           \u2013            <p>If <code>True</code>, the user is marked as AFK. If <code>False</code>, the user is marked as being active. If undefined, this will not be changed.</p> </li> <li> <code>activity</code>               (<code>UndefinedNoneOr[Activity]</code>, default:                   <code>UNDEFINED</code> )           \u2013            <p>The activity to appear to be playing. If undefined, this will not be changed.</p> </li> <li> <code>status</code>               (<code>UndefinedOr[Status]</code>, default:                   <code>UNDEFINED</code> )           \u2013            <p>The web status to show. If undefined, this will not be changed.</p> </li> </ul>"},{"location":"reference/#hikari_orchestrator.Client.update_voice_state","title":"update_voice_state  <code>async</code>","text":"<pre><code>update_voice_state(guild, channel, *, self_mute=hikari.UNDEFINED, self_deaf=hikari.UNDEFINED)\n</code></pre> <p>Update the voice state in a given guild.</p> <p>Parameters:</p> <ul> <li> <code>guild</code>               (<code>SnowflakeishOr[PartialGuild]</code>)           \u2013            <p>The guild or guild ID to update the voice state for.</p> </li> <li> <code>channel</code>               (<code>SnowflakeishOr[GuildVoiceChannel] | None</code>)           \u2013            <p>The channel or channel ID to update the voice state for. If <code>None</code> then the bot will leave the voice channel that it is in for the given guild.</p> </li> <li> <code>self_mute</code>               (<code>UndefinedOr[bool]</code>, default:                   <code>UNDEFINED</code> )           \u2013            <p>If specified and <code>True</code>, the bot will mute itself in that voice channel. If <code>False</code>, then it will unmute itself.</p> </li> <li> <code>self_deaf</code>               (<code>UndefinedOr[bool]</code>, default:                   <code>UNDEFINED</code> )           \u2013            <p>If specified and <code>True</code>, the bot will deafen itself in that voice channel. If <code>False</code>, then it will undeafen itself.</p> </li> </ul>"},{"location":"reference/#hikari_orchestrator.run_server","title":"run_server","text":"<pre><code>run_server(token, address, /, *, intents=hikari.Intents.ALL_UNPRIVILEGED, ca_cert=None, private_key=None, shard_count=None)\n</code></pre> <p>Run an Orchestrator server instance.</p> <p>Parameters:</p> <ul> <li> <code>token</code>               (<code>str</code>)           \u2013            <p>Discord token of the bot this orchestrator serve is managing.</p> </li> <li> <code>address</code>               (<code>str</code>)           \u2013            <p>The address to host the server at.</p> <p>This defaults to TCP if no scheme is included and more information on the supported schemes can be found here.</p> </li> <li> <code>intents</code>               (<code>Intents | int</code>, default:                   <code>ALL_UNPRIVILEGED</code> )           \u2013            <p>The Discord gateway intents this bot should run with.</p> </li> <li> <code>ca_cert</code>               (<code>bytes | None</code>, default:                   <code>None</code> )           \u2013            <p>Bytes of the unencrypted PEM certificate authority this should use for TLS SSL encryption.</p> <p><code>private_key</code> must also be passed when this is provided.</p> </li> <li> <code>private_key</code>               (<code>bytes | None</code>, default:                   <code>None</code> )           \u2013            <p>Bytes of the unencrypted private PEM key this server should use for TLS SSL encryption.</p> <p><code>ca_cert</code> must also be passed when this is proivded.</p> </li> <li> <code>shard_count</code>               (<code>int | None</code>, default:                   <code>None</code> )           \u2013            <p>The amount of shards this bot should be split into.</p> <p>If left as None then this defaults to the shard count recommended by Discord.</p> </li> </ul>"},{"location":"reference/#hikari_orchestrator.run_subprocesses","title":"run_subprocesses","text":"<pre><code>run_subprocesses(token, /, *, callback=None, shard_count=None, intents=hikari.Intents.ALL_UNPRIVILEGED, subprocess_count=DEFAULT_SUBPROCESS_COUNT)\n</code></pre> <p>Run a bot across several procsesses.</p> <p>Parameters:</p> <ul> <li> <code>token</code>               (<code>str</code>)           \u2013            <p>Discord token of the bot</p> </li> <li> <code>callback</code>               (<code>Callable[[GatewayBotAware], None] | None</code>, default:                   <code>None</code> )           \u2013            <p>Callback to call each child bot instance with on startup.</p> <p>This is used to setup the bot.</p> </li> <li> <code>shard_count</code>               (<code>int | None</code>, default:                   <code>None</code> )           \u2013            <p>The amount of shards this bot should be split into.</p> <p>If left as None then this defaults to the shard count recommended by Discord.</p> </li> <li> <code>intents</code>               (<code>Intents | int</code>, default:                   <code>ALL_UNPRIVILEGED</code> )           \u2013            <p>The Discord gateway intents this bot should run with.</p> </li> <li> <code>subprocess_count</code>               (<code>int</code>, default:                   <code>DEFAULT_SUBPROCESS_COUNT</code> )           \u2013            <p>The amount of subprocesses to spawn.</p> <p>If left as undefined then the current system's thread count is used. This will never spawn more subprocesses than <code>shard_count</code>.</p> </li> </ul>"},{"location":"reference/#hikari_orchestrator.spawn_subprocesses","title":"spawn_subprocesses  <code>async</code>","text":"<pre><code>spawn_subprocesses(token, /, *, callback=None, shard_count=None, intents=hikari.Intents.ALL_UNPRIVILEGED, subprocess_count=DEFAULT_SUBPROCESS_COUNT)\n</code></pre> <p>Asynchronously variant of run_subprocesses.</p> <p>The returned coroutine will finish once the server has closed.</p>"}]}